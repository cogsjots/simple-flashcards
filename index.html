<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Print Flashcards</title>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RW0BTZG13C"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-RW0BTZG13C');
  </script>

  <!-- Load Noto Sans Devanagari for crisp Hindi rendering -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Devanagari:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --color-front-text: #3f75ab;
      --color-back-text: #5e5e5e;
      --color-back-front-text: #9c9c9c;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      padding: 20px;
      background: #f4f4f8;
      color: #333;
    }

    h1 {
      text-align: center;
      color: #2c3e50;
    }

    .controls {
      max-width: 600px;
      margin: 20px auto;
      padding: 20px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .controls label {
      display: block;
      margin: 10px 0 5px;
      font-weight: bold;
    }

    .input-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    .input-row label {
      flex: 1;
      font-weight: bold;
      text-align: right;
      padding-right: 8px;
    }

    /* Add invisible placeholder to preserve input-side space */
    .input-row.advanced-row::after {
      content: "";
      flex: 2; /* Matches input field size */
    }

    .advanced-toggle {
      flex: 1;
      text-align: right;
      padding-right: 8px;
      margin-top: 15px;
      cursor: pointer;
      text-decoration: none;
      color: #3498db;
      font-size: 0.9em;
    }

    .input-row .value-preview {
      font-family: monospace;
      font-size: 0.9em;
      background: transparent;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      white-space: nowrap;
      width: 70px;
      text-align: center;
      font-weight: bold;
    }

    .input-row input[type="number"],
    .input-row input[type="file"] {
      flex: 2;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .input-row input[type="color"] {
      -webkit-appearance: none; /* reset browser default styling */
      /* width: 60px;
      height: 30px; */
      /* flex: 1; */
      border: none;
      cursor: pointer;
      border-radius: 12px;
      /* border: 2px solid #333; */     
    }

    /* WebKit (Chrome, Edge, Safari) needs special rule for the swatch */
    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      border-radius: 12px;
    }

    input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 12px;
    }

    .input-row .span-input {
      flex: 2;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .advanced-section {
      display: none;
      margin-top: 15px;
    }

    .button-row {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .controls button {
      width: 100%;
      padding: 10px;
      margin: 15px 0 5px;
      background: #3498db;
      color: white;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .controls button:hover:enabled {
      background: #2980b9;
    }

    .controls button:disabled {
      background: #bdc3c7;
      cursor: not-allowed;
    }

    #output {
      display: none;
    }

    #errorMessages {
      margin-top: 10px;
      padding: 10px;
      background: #ffe6e6;
      border: 1px solid #ff9999;
      border-radius: 4px;
      color: #d00;
      font-size: 0.9em;
      display: none;
    }

    @media print {
      #errorMessages, .no-print {
        display: none !important;
      }

      body * {
        visibility: hidden;
      }

      .print-section,
      .print-section * {
        visibility: visible;
      }

      .print-section {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
      }

      .card-page {
        page-break-after: always;
        margin: 0 !important;
        padding: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
      }

      .card {
        break-inside: avoid;
      }
    }

    .print-section {
      display: none;
    }

    .card-page {
      display: grid;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
    }

    .card {
      background: white;
      border: 1px solid #ccc;
      border-radius: 0; /* Sharp edges for clean cutting */
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 10px;
      box-sizing: border-box;
      overflow: hidden;
      page-break-inside: avoid;
      break-inside: avoid;
    }

    .category-label {
      position: absolute;
      top: 5px;
      right: 5px; /* Now on top-right */
      font-size: 0.7em;
      color: #555;
      background: rgba(255, 255, 255, 0.8);
      padding: 2px 6px;
      border-radius: 4px;
      z-index: 10;
      font-family: 'Noto Sans Devanagari', 'Segoe UI', sans-serif;
    }

    .card-content {
      font-size: 1.4em;
      font-weight: bold;
      line-height: 1.4;
      flex: 1;
      display: flex;
      flex-direction: column; /* Changed to column for subtext */
      align-items: center;
      justify-content: center;
      width: 90%;
      text-align: center;
      padding: 10px;
      box-sizing: border-box;
      /* Apply Hindi font to content */
      /* font-family: 'Noto Sans Devanagari', 'Segoe UI', sans-serif; */
    }

    .front .card-content {
      color: var(--color-front-text);
      font-size: 1.5em;
    }

    .back .card-content {
     /*  flex-direction: column; */ /* Removed as it's now default */
      gap: 4px;
      color: var(--color-back-text);
    }

    .back-front-text {
      font-size: 0.9em;
      color: var(--color-back-front-text);
      font-weight: normal;
      /* margin-bottom: 5px; */
    }
  </style>
</head>

<body>

  <h1>Print Flashcards</h1>

  <div class="controls">
    <div class="input-row">
      <label>Upload CSV File:</label>
      <input type="file" id="csvFile" accept=".csv" />
    </div>
    <div class="input-row">
      <label></label>
      <small>
        Need a template?
        <a href="sample.csv" download>Download sample.csv</a>
      </small>
    </div>

    <div class="input-row">
      <label>Rows per Page:</label>
      <input type="number" id="rows" value="4" min="1" max="10" />
    </div>

    <div class="input-row">
      <label>Columns per Page:</label>
      <input type="number" id="cols" value="2" min="1" max="5" />
    </div>

    <div class="input-row advanced-row">
      <div class="advanced-toggle" onclick="toggleAdvanced()">
        Advanced Options ▶
      </div>
    </div>
    <div id="advancedSection" class="advanced-section">
      <div class="input-row">
        <label style="height: auto;">Show front on back:</label>
        <div style="flex: 2; display: flex; align-items: center; gap: 10px;">
          <input type="checkbox" id="showFrontOnBack" style="height: auto;" />
          <span style="font-size: 0.9em; color: #555;">Enable</span>
        </div>
      </div>

      <div class="input-row">
        <label>Front Text Color:</label>
        <div class="span-input">
          <span class="value-preview" id="previewFront"></span>
          <input type="color" id="colorFront" oninput="updatePreview('colorFront', 'previewFront')" />
        </div>
      </div>

      <div class="input-row">
        <label>Back Text Color:</label>
        <div class="span-input">
          <span class="value-preview" id="previewBack"></span>
          <input type="color" id="colorBack" oninput="updatePreview('colorBack', 'previewBack')" />
        </div>
      </div>

      <div class="input-row">
        <label>Front on Back Color:</label>
        <div class="span-input">
          <span class="value-preview" id="previewBackFront"></span>
          <input type="color" id="colorBackFront" oninput="updatePreview('colorBackFront', 'previewBackFront')" />
        </div>
      </div>
    </div>

    <div class="button-row">
      <button id="generateBtn">Generate Flashcards</button>
      <button id="printBtn" onclick="window.print()" disabled>Print or Save as PDF</button>
    </div>
    <div id="errorMessages"></div>
  </div>

  <div id="output" class="print-section"></div>

  <script>
    function toggleAdvanced() {
      const section = document.getElementById("advancedSection");
      const toggle = document.querySelector(".advanced-toggle");
      if (section.style.display === "block") {
        section.style.display = "none";
        toggle.textContent = "Advanced Options ▶";
      } else {
        section.style.display = "block";
        toggle.textContent = "Advanced Options ▼";
      }
    }

    function updatePreview(inputId, previewId) {
      const input = document.getElementById(inputId);
      const preview = document.getElementById(previewId);
      preview.textContent = input.value;
      preview.style.color = input.value; // Set text color to the selected color
    }

    // Initialize preview colors from CSS variables
    window.onload = function () {
      // Get computed style for root element
      const rootStyles = getComputedStyle(document.documentElement);

      // Set color inputs from CSS variables
      document.getElementById('colorFront').value = rootStyles.getPropertyValue('--color-front-text').trim();
      document.getElementById('colorBack').value = rootStyles.getPropertyValue('--color-back-text').trim();
      document.getElementById('colorBackFront').value = rootStyles.getPropertyValue('--color-back-front-text').trim();
      
      // Update previews
      updatePreview('colorFront', 'previewFront');
      updatePreview('colorBack', 'previewBack');
      updatePreview('colorBackFront', 'previewBackFront');
    };

    document.getElementById("generateBtn").addEventListener("click", handleGenerate);

    function handleGenerate() {
      const fileInput = document.getElementById("csvFile");
      const rows = parseInt(document.getElementById("rows").value);
      const cols = parseInt(document.getElementById("cols").value);
      const showFrontOnBack = document.getElementById("showFrontOnBack").checked;
      const colorFront = document.getElementById("colorFront").value;
      const colorBack = document.getElementById("colorBack").value;
      const colorBackFront = document.getElementById("colorBackFront").value;
      const output = document.getElementById("output");
      const errorMsg = document.getElementById("errorMessages");
      errorMsg.style.display = "none";
      errorMsg.innerHTML = "";

      if (!fileInput.files || fileInput.files.length === 0) {
        errorMsg.innerHTML = "Please select a CSV file.";
        errorMsg.style.display = "block";
        return;
      }

      // Set CSS variables for colors
      document.documentElement.style.setProperty('--color-front-text', colorFront);
      document.documentElement.style.setProperty('--color-back-text', colorBack);
      document.documentElement.style.setProperty('--color-back-front-text', colorBackFront);

      const file = fileInput.files[0];
      const reader = new FileReader();

      reader.onload = function (e) {
        const csv = e.target.result;
        const { data, warnings } = parseCSV(csv);

        if (warnings.length > 0) {
          errorMsg.innerHTML = warnings.join("<br>");
          errorMsg.style.display = "block";
        } else {
          errorMsg.style.display = "none";
        }

        if (data.length === 0) {
          errorMsg.innerHTML = "CSV file is empty or in incorrect format. Ensure it has headers: category,front,back[,front-subtext,back-subtext]";
          errorMsg.style.display = "block";
          return;
        }

        // --- NEW CODE: Pad data to fill last row ---
        const cardsPerPage = rows * cols;
        const remainder = data.length % cols;
        if (remainder !== 0) {
          const paddingNeeded = cols - remainder;
          console.log(`Adding ${paddingNeeded} empty cards to fill the last row.`);
          for (let i = 0; i < paddingNeeded; i++) {
            // Add an empty object. The generate function will need to handle these.
            data.push({ category: "", front: "", back: "", "front-subtext": "", "back-subtext": "" });
          }
        }
        // --- END NEW CODE ---

        generateFlashcards(data, rows, cols, showFrontOnBack, output);
        output.style.display = "block";
        document.getElementById("printBtn").disabled = false; // enable print
      };

      reader.readAsText(file);
    }

    // Robust CSV parser that handles quoted fields with commas
    function parseCSV(csv) {
      const lines = [];
      const warnings = [];
      let currentLine = "";
      let inQuotes = false;

      // Process character by character to preserve newlines inside quotes
      for (let i = 0; i < csv.length; i++) {
        const char = csv[i];
        const nextChar = i < csv.length - 1 ? csv[i + 1] : '';

        currentLine += char;

        if (char === '"') {
          if (inQuotes && nextChar === '"') {
            // Escaped quote ""
            i++;
            currentLine += '"';
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === '\n' && !inQuotes) {
          lines.push(currentLine.trim());
          currentLine = "";
        }
      }
      if (currentLine) lines.push(currentLine.trim());

      if (lines.length === 0 || !lines[0]) {
        warnings.push("CSV is empty.");
        return { data: [], warnings };
      }

      const headers = lines[0].split(",").map(h => h.trim().toLowerCase());
      const data = [];

      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        if (!line.trim()) continue;

        const values = [];
        let inQuotes = false;
        let currentValue = "";

        for (let char of line) {
          if (char === '"' && !inQuotes) {
            inQuotes = true;
            currentValue += '"';
          } else if (char === '"' && inQuotes) {
            inQuotes = false;
            currentValue += '"';
          } else if (char === ',' && !inQuotes) {
            values.push(currentValue);
            currentValue = "";
          } else {
            currentValue += char;
          }
        }
        values.push(currentValue);

        if (values.length !== headers.length) {
          warnings.push(`Row ${i + 1}: Expected ${headers.length} columns, found ${values.length}.`);
          continue;
        }

        const entry = {};
        headers.forEach((h, idx) => {
          let val = values[idx].trim();
          // Remove surrounding quotes and convert internal \n to <br>
          if (val.startsWith('"') && val.endsWith('"')) {
            val = val.slice(1, -1).replace(/""/g, '"').replace(/\n/g, '<br>').replace(/\\n/g, '<br>');
          }
          entry[h] = val;
        });
        data.push(entry);
      }

      return { data, warnings };
    }

    function fontResize(text) {
      const len = (text || "").length; // Handle potential undefined/null text
      const fontSize = len > 50 ? "1.0rem" :
                       len > 30 ? "1.3rem" :
                       len > 20 ? "1.5rem" : "1.7rem";

      return fontSize;
    }

    function generateFlashcards(data, rows, cols, showFrontOnBack, output) {
      const cardsPerPage = rows * cols;
      output.innerHTML = "";

      // Calculate card height and width to fill the page exactly
      const cardHeight = `calc(100vh / ${rows})`;
      const cardWidth = `calc(100vw / ${cols})`;

      document.documentElement.style.setProperty('--rows', rows);
      document.documentElement.style.setProperty('--cols', cols);

      // === FRONT PAGES ===
      for (let i = 0; i < data.length; i += cardsPerPage) {
        const page = document.createElement("div");
        page.className = "card-page front";
        page.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
        page.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

        for (let j = 0; j < cardsPerPage; j++) {
          const idx = i + j;
          if (idx >= data.length) break;

          const item = data[idx]; // Get the item object
          const card = document.createElement("div");
          card.className = "card front";
          card.style.height = cardHeight;
          card.style.width = cardWidth;

          const categoryLabel = document.createElement("div");
          categoryLabel.className = "category-label";
          categoryLabel.textContent = item.category || "---";

          const content = document.createElement("div");
          content.className = "card-content";

          // Auto font size based on text length
          const text = item.front;
          const mainFontSize = fontResize(text);
          content.style.fontSize = mainFontSize;
          // content.innerHTML = text; // Move innerHTML setting after subtext

          // Create element for main front text
          const frontTextElement = document.createElement("div");
          frontTextElement.innerHTML = text;

          // Check for and add front-subtext
          const frontSubtext = item['front-subtext'];
          let frontSubtextElement = null;
          if (frontSubtext && frontSubtext.trim() !== "") {
            frontSubtextElement = document.createElement("div");
            frontSubtextElement.className = "subtext";
            frontSubtextElement.innerHTML = frontSubtext;
            // Calculate subtext font size relative to main text
            frontSubtextElement.style.fontSize = `calc(${mainFontSize} * 0.7)`;
          }

          card.appendChild(categoryLabel);
          content.appendChild(frontTextElement);
          if (frontSubtextElement) {
            content.appendChild(frontSubtextElement);
          }
          card.appendChild(content);
          page.appendChild(card);
        }
        output.appendChild(page);
      }

      // === BACK PAGES (mirrored column order per row)
      for (let i = 0; i < data.length; i += cardsPerPage) {
        const page = document.createElement("div");
        page.className = "card-page back";
        page.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
        page.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

        // Process each row
        for (let rowIdx = 0; rowIdx < rows; rowIdx++) {
          const cardsInRow = [];
          for (let colIdx = 0; colIdx < cols; colIdx++) {
            const idx = i + rowIdx * cols + colIdx;
            if (idx >= data.length) break;
            cardsInRow.push(data[idx]);
          }

          // Mirror for correct back alignment
          // Reverse the row → [Col3, Col2, Col1]
          cardsInRow.reverse();

          // Append in reversed (mirrored) order
          cardsInRow.forEach(item => {
            const card = document.createElement("div");
            card.className = "card back";
            card.style.height = cardHeight;
            card.style.width = cardWidth;

            const categoryLabel = document.createElement("div");
            categoryLabel.className = "category-label";
            categoryLabel.textContent = item.category || "---";

            const content = document.createElement("div");
            content.className = "card-content";

            // Check for and add front text on back (if enabled)
            let backFrontTextElement = null;
            let backFrontSubtextElement = null; // For front-subtext on back
            if (showFrontOnBack) {
              const frontText = item.front;
              backFrontTextElement = document.createElement("div");
              backFrontTextElement.className = "back-front-text";
              const frontFontSize = fontResize(frontText);
              backFrontTextElement.style.fontSize = `calc(${frontFontSize} * 0.7)`; // As before
              backFrontTextElement.innerHTML = frontText;

            }

            // Main back text
            const backText = item.back;
            const backMainTextElement = document.createElement("div");
            // backMainTextElement.style.fontSize = item.back.length > 50 ? "1.0em" :
            //   item.back.length > 30 ? "1.3em" : "1.5em";
            const backMainFontSize = fontResize(backText);
            backMainTextElement.style.fontSize = backMainFontSize;
            backMainTextElement.innerHTML = backText;

            // Check for and add back-subtext
            const backSubtext = item['back-subtext'];
            let backSubtextElement = null;
            if (backSubtext && backSubtext.trim() !== "") {
              backSubtextElement = document.createElement("div");
              backSubtextElement.className = "subtext";
              backSubtextElement.innerHTML = backSubtext;
              // Calculate subtext font size relative to main back text
              backSubtextElement.style.fontSize = `calc(${backMainFontSize} * 0.7)`;
            }

            card.appendChild(categoryLabel);
            if (backFrontTextElement) {
              content.appendChild(backFrontTextElement);
            }
            content.appendChild(backMainTextElement); // Append main back text
            if (backSubtextElement) {
              content.appendChild(backSubtextElement); // Append back subtext last
            }
            card.appendChild(content);
            page.appendChild(card);
          });
        }
        output.appendChild(page);
      }
    }

    function disablePrint() {
      document.getElementById("printBtn").disabled = true;
    }

  ["csvFile", "rows", "cols", "showFrontOnBack",
    "colorFront", "colorBack", "colorBackFront"]
    .forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener("input", disablePrint);
        el.addEventListener("change", disablePrint);
      }
    });


  </script>

</body>
</html>
